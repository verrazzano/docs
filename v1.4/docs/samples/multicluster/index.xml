<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Verrazzano Enterprise Container Platform â€“ Multicluster</title>
    <link>/docs/samples/multicluster/</link>
    <description>Recent content in Multicluster on Verrazzano Enterprise Container Platform</description>
    <generator>Hugo -- gohugo.io</generator>
    
	  <atom:link href="/docs/samples/multicluster/index.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Docs: Multicluster Hello World Helidon</title>
      <link>/docs/samples/multicluster/hello-helidon/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/samples/multicluster/hello-helidon/</guid>
      <description>
        
        
        &lt;p&gt;The Hello World Helidon example is a Helidon-based service that returns a &amp;ldquo;Hello World&amp;rdquo; response when invoked. The example application is specified using Open Application Model (OAM) component and application configuration YAML files, and then deployed by applying those files.  This example shows how to deploy the Hello World Helidon application in a multicluster environment.&lt;/p&gt;
&lt;h2 id=&#34;before-you-begin&#34;&gt;Before you begin&lt;/h2&gt;
&lt;p&gt;Create a multicluster Verrazzano installation with one admin and one managed cluster, and register the managed cluster, by following the instructions &lt;a href=&#34;../../../docs/setup/install/multicluster/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Set up the following environment variables to point to the kubeconfig file for the admin and managed clusters.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ export KUBECONFIG_ADMIN=/path/to/your/adminclusterkubeconfig
$ export KUBECONFIG_MANAGED1=/path/to/your/managedclusterkubeconfig
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt;  The Hello World Helidon application deployment files are contained in the Verrazzano project located at
&lt;code&gt;&amp;lt;VERRAZZANO_HOME&amp;gt;/examples/multicluster/hello-helidon&lt;/code&gt;, where &lt;code&gt;&amp;lt;VERRAZZANO_HOME&amp;gt;&lt;/code&gt; is the root of the Verrazzano project.&lt;/p&gt;
&lt;h2 id=&#34;create-the-application-namespace&#34;&gt;Create the application namespace&lt;/h2&gt;
&lt;p&gt;Apply the VerrazzanoProject resource on the admin cluster that defines the namespace for the application.  The namespaces defined in the VerrazzanoProject resource will be created on the admin cluster and all the managed clusters.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ kubectl --kubeconfig $KUBECONFIG_ADMIN apply \
    -f https://raw.githubusercontent.com/verrazzano/verrazzano/v1.4.8/examples/multicluster/hello-helidon/verrazzano-project.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;deploy-the-application&#34;&gt;Deploy the application&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Apply the &lt;code&gt;hello-helidon&lt;/code&gt; multicluster application configuration resource to deploy the application.  The multicluster resource is an envelope that contains an OAM resource and a list of clusters to which to deploy.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ kubectl --kubeconfig $KUBECONFIG_ADMIN apply \
    -f https://raw.githubusercontent.com/verrazzano/verrazzano/v1.4.8/examples/multicluster/hello-helidon/hello-helidon-comp.yaml
$ kubectl --kubeconfig $KUBECONFIG_ADMIN apply \
    -f https://raw.githubusercontent.com/verrazzano/verrazzano/v1.4.8/examples/multicluster/hello-helidon/mc-hello-helidon-app.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Wait for the application to be ready on the managed cluster.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ kubectl --kubeconfig $KUBECONFIG_MANAGED1 wait \
    --for=condition=Ready pods \
    --all -n hello-helidon \
    --timeout=300s
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;explore-the-example-application&#34;&gt;Explore the example application&lt;/h2&gt;
&lt;p&gt;Follow the instructions for &lt;a href=&#34;../../../docs/samples/hello-helidon/#explore-the-application&#34;&gt;exploring&lt;/a&gt; the Hello World Helidon application in a single cluster use case. Use the managed cluster kubeconfig file for testing the example application.&lt;/p&gt;
&lt;h2 id=&#34;verify-the-deployed-application&#34;&gt;Verify the deployed application&lt;/h2&gt;
&lt;p&gt;Follow the instructions for &lt;a href=&#34;../../../docs/samples/hello-helidon/#troubleshooting&#34;&gt;troubleshooting&lt;/a&gt; the Hello World Helidon application in a single cluster use case. Use the managed cluster kubeconfig file for troubleshooting the example application.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Verify that the application namespace exists on the managed cluster.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ kubectl --kubeconfig $KUBECONFIG_MANAGED1 get namespace hello-helidon
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Verify that the multicluster resource for the application exists.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ kubectl --kubeconfig $KUBECONFIG_MANAGED1 get MultiClusterApplicationConfiguration -n hello-helidon
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;locating-the-application-on-a-different-cluster&#34;&gt;Locating the application on a different cluster&lt;/h2&gt;
&lt;p&gt;By default, the application is located on the managed cluster called &lt;code&gt;managed1&lt;/code&gt;. You can change the application&amp;rsquo;s location to be on a different cluster, which can be the admin cluster or a different managed cluster. In this example, you change the placement of the application to the admin cluster by patching the multicluster resources.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;To change the application&amp;rsquo;s location to the admin cluster, specify the change placement patch file.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# To change the placement to the admin cluster
$ export CHANGE_PLACEMENT_PATCH_FILE=&amp;#34;https://raw.githubusercontent.com/verrazzano/verrazzano/v1.4.8/examples/multicluster/hello-helidon/patch-change-placement-to-admin.yaml&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This environment variable is used in subsequent steps.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;To change its placement, patch the &lt;code&gt;hello-helidon&lt;/code&gt; multicluster application configuration.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ kubectl --kubeconfig $KUBECONFIG_ADMIN patch mcappconf hello-helidon-appconf \
    -n hello-helidon \
    --type merge \
    --patch &amp;#34;$(curl -s $CHANGE_PLACEMENT_PATCH_FILE)&amp;#34;

# Expected response
multiclusterapplicationconfiguration.clusters.verrazzano.io/hello-helidon-appconf patched
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;To verify that its placement has changed, view the multicluster resource.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ kubectl --kubeconfig $KUBECONFIG_ADMIN get mcappconf hello-helidon-appconf \
    -n hello-helidon \
    -o jsonpath=&amp;#39;{.spec.placement}&amp;#39;;echo

# Expected response
{&amp;#34;clusters&amp;#34;:[{&amp;#34;name&amp;#34;:&amp;#34;local&amp;#34;}]}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The cluster
name, &lt;code&gt;local&lt;/code&gt;, indicates placement in the admin cluster.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;To change its placement, patch the VerrazzanoProject.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ kubectl --kubeconfig $KUBECONFIG_ADMIN patch vp hello-helidon \
    -n verrazzano-mc \
    --type merge \
    --patch &amp;#34;$(curl -s $CHANGE_PLACEMENT_PATCH_FILE)&amp;#34;

# Expected response
verrazzanoproject.clusters.verrazzano.io/hello-helidon patched
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Wait for the application to be ready on the admin cluster.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ kubectl --kubeconfig $KUBECONFIG_ADMIN wait \
    --for=condition=Ready pods \
    --all -n hello-helidon \
    --timeout=300s
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; If you are returning the application to the managed cluster, then instead, wait for the application to be
ready on the managed cluster.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ kubectl --kubeconfig $KUBECONFIG_MANAGED1 wait \
    --for=condition=Ready pods \
    --all -n hello-helidon \
    --timeout=300s
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Now, you can test the example application running in its new location.&lt;/p&gt;
&lt;p&gt;To return the application to the managed cluster named &lt;code&gt;managed1&lt;/code&gt;, set the value of the &lt;code&gt;CHANGE_PLACEMENT_PATCH_FILE&lt;/code&gt; environment variable to the patch file provided for that purpose, then repeat the previous numbered steps.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# To change the placement back to the managed cluster named managed1
$ export CHANGE_PLACEMENT_PATCH_FILE=&amp;#34;https://raw.githubusercontent.com/verrazzano/verrazzano/v1.4.8/examples/multicluster/hello-helidon/patch-return-placement-to-managed1.yaml&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;undeploy-the-application&#34;&gt;Undeploy the application&lt;/h2&gt;
&lt;p&gt;Regardless of its location, to undeploy the application,
delete the application resources and the project from the admin cluster.
Undeploy affects all clusters in which the application is located.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;To undeploy the application, delete the Hello World Helidon OAM resources.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ kubectl --kubeconfig $KUBECONFIG_ADMIN delete \
    -f https://raw.githubusercontent.com/verrazzano/verrazzano/v1.4.8/examples/multicluster/hello-helidon/mc-hello-helidon-app.yaml
$ kubectl --kubeconfig $KUBECONFIG_ADMIN delete \
    -f https://raw.githubusercontent.com/verrazzano/verrazzano/v1.4.8/examples/multicluster/hello-helidon/hello-helidon-comp.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Delete the project.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ kubectl --kubeconfig $KUBECONFIG_ADMIN delete \
    -f https://raw.githubusercontent.com/verrazzano/verrazzano/v1.4.8/examples/multicluster/hello-helidon/verrazzano-project.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Delete the namespace &lt;code&gt;hello-helidon&lt;/code&gt; after the application pod is terminated.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ kubectl --kubeconfig $KUBECONFIG_ADMIN delete namespace hello-helidon
$ kubectl --kubeconfig $KUBECONFIG_MANAGED1 delete namespace hello-helidon
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Multicluster Helidon Sock Shop</title>
      <link>/docs/samples/multicluster/sock-shop/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/samples/multicluster/sock-shop/</guid>
      <description>
        
        
        &lt;p&gt;This example application provides a &lt;a href=&#34;https://helidon.io&#34;&gt;Helidon&lt;/a&gt; implementation of the &lt;a href=&#34;https://microservices-demo.github.io/&#34;&gt;Sock Shop Microservices Demo Application&lt;/a&gt;.
It uses OAM resources to define the application deployment in a multicluster environment.&lt;/p&gt;
&lt;h2 id=&#34;before-you-begin&#34;&gt;Before you begin&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Set up a multicluster Verrazzano environment following the &lt;a href=&#34;../../../docs/setup/install/multicluster/&#34;&gt;installation instructions&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;The example assumes that there is a managed cluster named &lt;code&gt;managed1&lt;/code&gt; associated with the multicluster environment.
If your environment does not have a cluster of that name, then you should edit the deployment files and change the cluster name
listed in the &lt;code&gt;placement&lt;/code&gt; section.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Set up the following environment variables to point to the kubeconfig file for the admin and managed clusters.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ export KUBECONFIG_ADMIN=/path/to/your/adminclusterkubeconfig
$ export KUBECONFIG_MANAGED1=/path/to/your/managedclusterkubeconfig
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; The Sock Shop application deployment files are contained in the Verrazzano project located at
&lt;code&gt;&amp;lt;VERRAZZANO_HOME&amp;gt;/examples/multicluster/sockshop&lt;/code&gt;, where &lt;code&gt;&amp;lt;VERRAZZANO_HOME&amp;gt;&lt;/code&gt; is the root of the Verrazzano project.&lt;/p&gt;
&lt;h2 id=&#34;deploy-the-application&#34;&gt;Deploy the application&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Create a namespace for the Sock Shop application by deploying the Verrazzano project.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ kubectl --kubeconfig $KUBECONFIG_ADMIN apply \
    -f https://raw.githubusercontent.com/verrazzano/verrazzano/v1.4.8/examples/multicluster/sock-shop/verrazzano-project.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Apply the Sock Shop OAM resources to deploy the application.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ kubectl --kubeconfig $KUBECONFIG_ADMIN apply \
    -f https://raw.githubusercontent.com/verrazzano/verrazzano/v1.4.8/examples/multicluster/sock-shop/sock-shop-comp.yaml
$ kubectl --kubeconfig $KUBECONFIG_ADMIN apply \
    -f https://raw.githubusercontent.com/verrazzano/verrazzano/v1.4.8/examples/multicluster/sock-shop/sock-shop-app.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Wait for the Sock Shop application to be ready.  It may take a few minutes for the pod resources to start appearing on the managed cluster.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ kubectl --kubeconfig $KUBECONFIG_MANAGED1 wait \
    --for=condition=Ready pods \
    --all -n mc-sockshop \
    --timeout=300s
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;explore-the-application&#34;&gt;Explore the application&lt;/h2&gt;
&lt;p&gt;The Sock Shop microservices application implements REST API endpoints including:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;/catalogue&lt;/code&gt; - Returns the Sock Shop catalog.
This endpoint accepts the &lt;code&gt;GET&lt;/code&gt; HTTP request method.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/register&lt;/code&gt; - POST &lt;code&gt;{ &amp;quot;username&amp;quot;:&amp;quot;xxx&amp;quot;, &amp;quot;password&amp;quot;:&amp;quot;***&amp;quot;, &amp;quot;email&amp;quot;:&amp;quot;foo@example.com&amp;quot;, &amp;quot;firstName&amp;quot;:&amp;quot;foo&amp;quot;, &amp;quot;lastName&amp;quot;:&amp;quot;coo&amp;quot; }&lt;/code&gt; to create a user. This
endpoint accepts the &lt;code&gt;POST&lt;/code&gt; HTTP request method.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;:  The following instructions assume that you are using a Kubernetes
environment, such as OKE.  Other environments or deployments may require alternative mechanisms for retrieving addresses,
ports, and such.&lt;/p&gt;
&lt;p&gt;Follow these steps to test the endpoints.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Get the generated host name for the application.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ HOST=$(kubectl --kubeconfig $KUBECONFIG_MANAGED1 get gateway \
      -n mc-sockshop \
      -o jsonpath={.items[0].spec.servers[0].hosts[0]})
$ echo $HOST

# Sample output
sockshop-appconf.mc-sockshop.11.22.33.44.nip.io
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Get the &lt;code&gt;EXTERNAL_IP&lt;/code&gt; address of the &lt;code&gt;istio-ingressgateway&lt;/code&gt; service.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ ADDRESS=$(kubectl --kubeconfig $KUBECONFIG_MANAGED1 get service \
    -n istio-system istio-ingressgateway \
    -o jsonpath=&amp;#39;{.status.loadBalancer.ingress[0].ip}&amp;#39;)
$ echo $ADDRESS

# Sample output
11.22.33.44
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Access the Sock Shop example application.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Using the command line&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# Get catalogue
$ curl -sk \
    -X GET \
    https://${HOST}/catalogue \
    --resolve ${HOST}:443:${ADDRESS}

# Sample output
[{&amp;#34;count&amp;#34;:115,&amp;#34;description&amp;#34;:&amp;#34;For all those leg lovers out there....&amp;#34;, ...}]

# Add a new user (replace values of username and password)
$ curl -i \
    --header &amp;#34;Content-Type: application/json&amp;#34; --request POST \
    --data &amp;#39;{&amp;#34;username&amp;#34;:&amp;#34;foo&amp;#34;,&amp;#34;password&amp;#34;:&amp;#34;****&amp;#34;,&amp;#34;email&amp;#34;:&amp;#34;foo@example.com&amp;#34;,&amp;#34;firstName&amp;#34;:&amp;#34;foo&amp;#34;,&amp;#34;lastName&amp;#34;:&amp;#34;foo&amp;#34;}&amp;#39; \
    -k https://${HOST}/register \
    --resolve ${HOST}:443:${ADDRESS}

# Add an item to the user&amp;#39;s cart
$ curl -i \
    --header &amp;#34;Content-Type: application/json&amp;#34; --request POST \
    --data &amp;#39;{&amp;#34;itemId&amp;#34;: &amp;#34;a0a4f044-b040-410d-8ead-4de0446aec7e&amp;#34;,&amp;#34;unitPrice&amp;#34;: &amp;#34;7.99&amp;#34;}&amp;#39; \
    -k https://${HOST}/carts/{username}/items \
    --resolve ${HOST}:443:${ADDRESS}

# Sample output
{&amp;#34;itemId&amp;#34;:&amp;#34;a0a4f044-b040-410d-8ead-4de0446aec7e&amp;#34;,&amp;#34;quantity&amp;#34;:1,&amp;#34;unitPrice&amp;#34;:7.99}

# Get cart items
$ curl -i \
    -k https://${HOST}/carts/{username}/items \
    --resolve ${HOST}:443:${ADDRESS}

# Sample output
[{&amp;#34;itemId&amp;#34;:&amp;#34;a0a4f044-b040-410d-8ead-4de0446aec7e&amp;#34;,&amp;#34;quantity&amp;#34;:1,&amp;#34;unitPrice&amp;#34;:7.99}]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If you are using &lt;code&gt;nip.io&lt;/code&gt;, then you do not need to include &lt;code&gt;--resolve&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Local testing with a browser&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Temporarily, modify the &lt;code&gt;/etc/hosts&lt;/code&gt; file (on Mac or Linux)
or &lt;code&gt;c:\Windows\System32\Drivers\etc\hosts&lt;/code&gt; file (on Windows 10),
to add an entry mapping the host name to the ingress gateway&amp;rsquo;s &lt;code&gt;EXTERNAL-IP&lt;/code&gt; address.
For example:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;11.22.33.44 sockshop.example.com
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Then, you can access the application in a browser at &lt;code&gt;https://sockshop.example.com/catalogue&lt;/code&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If you are using &lt;code&gt;nip.io&lt;/code&gt;, then you can access the application in a browser using the &lt;code&gt;HOST&lt;/code&gt; variable (for example, &lt;code&gt;https://${HOST}/catalogue&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;If you are going through a proxy, you may need to add &lt;code&gt;*.nip.io&lt;/code&gt; to the &lt;code&gt;NO_PROXY&lt;/code&gt; list.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Using your own DNS name&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Point your own DNS name to the ingress gateway&amp;rsquo;s &lt;code&gt;EXTERNAL-IP&lt;/code&gt; address.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;In this case, you would need to edit the &lt;code&gt;sock-shop-app.yaml&lt;/code&gt; file
to use the appropriate value under the &lt;code&gt;hosts&lt;/code&gt; section (such as &lt;code&gt;yourhost.your.domain&lt;/code&gt;),
before deploying the Sock Shop application.&lt;/li&gt;
&lt;li&gt;Then, you can use a browser to access the application at &lt;code&gt;https://&amp;lt;yourhost.your.domain&amp;gt;/catalogue&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;verify-the-deployed-application&#34;&gt;Verify the deployed application&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Verify that the application configuration, components, workloads, and ingress trait all exist.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ kubectl --kubeconfig $KUBECONFIG_MANAGED1 get ApplicationConfiguration -n mc-sockshop
$ kubectl --kubeconfig $KUBECONFIG_MANAGED1 get Component -n mc-sockshop
$ kubectl --kubeconfig $KUBECONFIG_MANAGED1 get VerrazzanoCoherenceWorkload -n mc-sockshop
$ kubectl --kubeconfig $KUBECONFIG_MANAGED1 get Coherence -n mc-sockshop
$ kubectl --kubeconfig $KUBECONFIG_MANAGED1 get IngressTrait -n mc-sockshop
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Verify that the Sock Shop service pods are successfully created and transition to the &lt;code&gt;READY&lt;/code&gt; state. Note that this may take a few minutes and that you may see some of the services terminate and restart.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt; $ kubectl --kubeconfig $KUBECONFIG_MANAGED1 get pods -n mc-sockshop

 # Sample output
 NAME             READY   STATUS    RESTARTS   AGE
 carts-coh-0      2/2     Running   0          38m
 catalog-coh-0    2/2     Running   0          38m
 orders-coh-0     2/2     Running   0          38m
 payment-coh-0    2/2     Running   0          38m
 shipping-coh-0   2/2     Running   0          38m
 users-coh-0      2/2     Running   0          38m
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A variety of endpoints are available to further explore the logs, metrics, and such, associated with
the deployed Sock Shop application.  You can access them according to the directions &lt;a href=&#34;../../../docs/access/#get-the-consoles-urls&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;undeploy-the-application&#34;&gt;Undeploy the application&lt;/h2&gt;
&lt;p&gt;Regardless of its location, to undeploy the application,
delete the application resources and the project from the admin cluster.
Undeploy affects all clusters in which the application is located.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;To undeploy the application, delete the Sock Shop OAM resources:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ kubectl --kubeconfig $KUBECONFIG_ADMIN delete \
  -f https://raw.githubusercontent.com/verrazzano/verrazzano/v1.4.8/examples/multicluster/sock-shop/sock-shop-app.yaml
$ kubectl --kubeconfig $KUBECONFIG_ADMIN delete \
  -f https://raw.githubusercontent.com/verrazzano/verrazzano/v1.4.8/examples/multicluster/sock-shop/sock-shop-comp.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Delete the project.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ kubectl --kubeconfig $KUBECONFIG_ADMIN delete \
 -f https://raw.githubusercontent.com/verrazzano/verrazzano/v1.4.8/examples/multicluster/sock-shop/verrazzano-project.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Delete the namespace &lt;code&gt;mc-sockshop&lt;/code&gt; after the application pods are terminated.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ kubectl --kubeconfig $KUBECONFIG_ADMIN delete namespace mc-sockshop
$ kubectl --kubeconfig $KUBECONFIG_MANAGED1 delete namespace mc-sockshop
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Multicluster ToDo List</title>
      <link>/docs/samples/multicluster/todo-list/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/docs/samples/multicluster/todo-list/</guid>
      <description>
        
        
        &lt;p&gt;ToDo List is an example application containing a WebLogic component.
For more information and the source code of this application, see the &lt;a href=&#34;https://github.com/verrazzano/examples&#34;&gt;Verrazzano Examples&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;before-you-begin&#34;&gt;Before you begin&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Set up a multicluster Verrazzano environment following the &lt;a href=&#34;../../../docs/setup/install/multicluster/&#34;&gt;installation instructions&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;The example assumes that there is a managed cluster named &lt;code&gt;managed1&lt;/code&gt; associated with the multicluster environment.
If your environment does not have a cluster of that name, then you should edit the deployment files and change the cluster name
listed in the &lt;code&gt;placement&lt;/code&gt; section.&lt;/li&gt;
&lt;li&gt;To download the example application image, you must first accept the license agreement.
&lt;ul&gt;
&lt;li&gt;In a browser, navigate to &lt;a href=&#34;https://container-registry.oracle.com/&#34;&gt;https://container-registry.oracle.com/&lt;/a&gt; and sign in.&lt;/li&gt;
&lt;li&gt;Search for &lt;code&gt;example-todo&lt;/code&gt; and &lt;code&gt;weblogic&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;For each one:
&lt;ul&gt;
&lt;li&gt;Select the image name in the results.&lt;/li&gt;
&lt;li&gt;From the drop-down menu, select your language and click Continue.&lt;/li&gt;
&lt;li&gt;Then read and accept the license agreement.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Set up the following environment variables to point to the kubeconfig file for the admin and managed clusters.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ export KUBECONFIG_ADMIN=/path/to/your/adminclusterkubeconfig
$ export KUBECONFIG_MANAGED1=/path/to/your/managedclusterkubeconfig
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; The ToDo List application deployment files are contained in the Verrazzano project located at
&lt;code&gt;&amp;lt;VERRAZZANO_HOME&amp;gt;/examples/multicluster/todo-list&lt;/code&gt;, where &lt;code&gt;&amp;lt;VERRAZZANO_HOME&amp;gt;&lt;/code&gt; is the root of the Verrazzano project.&lt;/p&gt;
&lt;h2 id=&#34;deploy-the-application&#34;&gt;Deploy the application&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Create a namespace for the multicluster ToDo List example by applying the Verrazzano project file.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ kubectl --kubeconfig $KUBECONFIG_ADMIN apply \
    -f https://raw.githubusercontent.com/verrazzano/verrazzano/v1.4.8/examples/multicluster/todo-list/verrazzano-project.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Create a &lt;code&gt;docker-registry&lt;/code&gt; secret to enable pulling the ToDo List example image from the registry.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ kubectl --kubeconfig $KUBECONFIG_ADMIN create secret docker-registry tododomain-repo-credentials \
        --docker-server=container-registry.oracle.com \
        --docker-username=YOUR_REGISTRY_USERNAME \
        --docker-password=YOUR_REGISTRY_PASSWORD \
        --docker-email=YOUR_REGISTRY_EMAIL \
        -n mc-todo-list
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Replace &lt;code&gt;YOUR_REGISTRY_USERNAME&lt;/code&gt;, &lt;code&gt;YOUR_REGISTRY_PASSWORD&lt;/code&gt;, and &lt;code&gt;YOUR_REGISTRY_EMAIL&lt;/code&gt;
with the values you use to access the registry.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Create and label secrets for the WebLogic domain:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# Replace the values of the WLS_USERNAME and WLS_PASSWORD environment variables as appropriate.
$ export WLS_USERNAME=&amp;lt;username&amp;gt;
$ export WLS_PASSWORD=&amp;lt;password&amp;gt;
$ kubectl --kubeconfig $KUBECONFIG_ADMIN create secret generic tododomain-weblogic-credentials \
    --from-literal=password=$WLS_PASSWORD \
    --from-literal=username=$WLS_USERNAME \
    -n mc-todo-list

$ kubectl --kubeconfig $KUBECONFIG_ADMIN create secret generic tododomain-jdbc-tododb \
    --from-literal=username=$WLS_USERNAME \
    --from-literal=password=$WLS_PASSWORD \
    -n mc-todo-list

$ kubectl --kubeconfig $KUBECONFIG_ADMIN -n mc-todo-list label secret tododomain-jdbc-tododb weblogic.domainUID=tododomain
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Note that the ToDo List example application is preconfigured to use specific secret names.
For the source code of this application, see the &lt;a href=&#34;https://github.com/verrazzano/examples&#34;&gt;Verrazzano Examples&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Apply the component and multicluster application resources to deploy the ToDo List application.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ kubectl --kubeconfig $KUBECONFIG_ADMIN apply \
    -f https://raw.githubusercontent.com/verrazzano/verrazzano/v1.4.8/examples/multicluster/todo-list/todo-list-components.yaml

$ kubectl --kubeconfig $KUBECONFIG_ADMIN apply \
    -f https://raw.githubusercontent.com/verrazzano/verrazzano/v1.4.8/examples/multicluster/todo-list/mc-todo-list-application.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Wait for the ToDo List example application to be ready.
The &lt;code&gt;tododomain-adminserver&lt;/code&gt; pod may take several minutes to be created and &lt;code&gt;Ready&lt;/code&gt;.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ kubectl --kubeconfig $KUBECONFIG_MANAGED1 wait pod \
    --for=condition=Ready tododomain-adminserver \
    -n mc-todo-list \
    --timeout=300s
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Get the generated host name for the application.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ HOST=$(kubectl --kubeconfig $KUBECONFIG_MANAGED1 get gateway \
      -n mc-todo-list \
      -o jsonpath=&amp;#39;{.items[0].spec.servers[0].hosts[0]}&amp;#39;)
$ echo $HOST

# Sample output
todo-appconf.mc-todo-list.11.22.33.44.nip.io
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Get the &lt;code&gt;EXTERNAL_IP&lt;/code&gt; address of the &lt;code&gt;istio-ingressgateway&lt;/code&gt; service.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ ADDRESS=$(kubectl --kubeconfig $KUBECONFIG_MANAGED1 get service \
     -n istio-system istio-ingressgateway \
     -o jsonpath=&amp;#39;{.status.loadBalancer.ingress[0].ip}&amp;#39;)
$ echo $ADDRESS

# Sample output
11.22.33.44
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Access the ToDo List example application.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Using the command line&lt;/strong&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# The expected response of this query is the HTML of a web page
$ curl -sk https://${HOST}/todo/ \
    --resolve ${HOST}:443:${ADDRESS}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If you are using &lt;code&gt;nip.io&lt;/code&gt;, then you do not need to include &lt;code&gt;--resolve&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Local testing with a browser&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Temporarily, modify the &lt;code&gt;/etc/hosts&lt;/code&gt; file (on Mac or Linux)
or &lt;code&gt;c:\Windows\System32\Drivers\etc\hosts&lt;/code&gt; file (on Windows 10),
to add an entry mapping the host name to the ingress gateway&amp;rsquo;s &lt;code&gt;EXTERNAL-IP&lt;/code&gt; address.
For example:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;11.22.33.44 todo.example.com
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Then, you can access the application in a browser at &lt;code&gt;https://todo.example.com/todo&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Using your own DNS name&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Point your own DNS name to the ingress gateway&amp;rsquo;s &lt;code&gt;EXTERNAL-IP&lt;/code&gt; address.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;In this case, you would need to have edited the &lt;code&gt;todo-list-application.yaml&lt;/code&gt; file
to use the appropriate value under the &lt;code&gt;hosts&lt;/code&gt; section (such as &lt;code&gt;yourhost.your.domain&lt;/code&gt;),
before deploying the ToDo List application.&lt;/li&gt;
&lt;li&gt;Then, you can use a browser to access the application at &lt;code&gt;https://&amp;lt;yourhost.your.domain&amp;gt;/todo/&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Accessing the application in a browser will open a page, &amp;ldquo;Derek&amp;rsquo;s ToDo List&amp;rdquo;,
with an edit field and an &lt;strong&gt;Add&lt;/strong&gt; button that lets add tasks.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A variety of endpoints associated with
the deployed ToDo List application are available to further explore the logs, metrics, and such.
You can access them according to the directions &lt;a href=&#34;../../../docs/access/#get-the-consoles-urls&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;verify-the-deployed-application&#34;&gt;Verify the deployed application&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Verify that the application configuration, domain, and ingress trait all exist.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ kubectl --kubeconfig $KUBECONFIG_MANAGED1 get ApplicationConfiguration -n mc-todo-list

# Sample output
NAME           AGE
todo-appconf   19h

$ kubectl --kubeconfig $KUBECONFIG_MANAGED1 get Domain -n mc-todo-list

# Sample output
NAME          AGE
todo-domain   19h

$ kubectl --kubeconfig $KUBECONFIG_MANAGED1 get IngressTrait -n mc-todo-list

# Sample output
NAME                           AGE
todo-domain-trait-7cbd798c96   19h
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Verify that the WebLogic Administration Server and MySQL pods have been created and are running.
Note that this will take several minutes.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ kubectl --kubeconfig $KUBECONFIG_MANAGED1 get pods -n mc-todo-list

# Sample output
NAME                     READY   STATUS    RESTARTS   AGE
mysql-5c75c8b7f-vlhck    2/2     Running   0          19h
tododomain-adminserver   4/4     Running   0          19h
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;undeploy-the-application&#34;&gt;Undeploy the application&lt;/h2&gt;
&lt;p&gt;Regardless of its location, to undeploy the application,
delete the application resources and the project from the admin cluster.
Undeploy affects all clusters in which the application is located.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;To undeploy the application, delete the ToDo List OAM resources.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ kubectl --kubeconfig $KUBECONFIG_ADMIN delete \
 -f https://raw.githubusercontent.com/verrazzano/verrazzano/v1.4.8/examples/multicluster/todo-list/mc-todo-list-application.yaml
$ kubectl --kubeconfig $KUBECONFIG_ADMIN delete \
 -f https://raw.githubusercontent.com/verrazzano/verrazzano/v1.4.8/examples/multicluster/todo-list/todo-list-components.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Delete the project.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ kubectl --kubeconfig $KUBECONFIG_ADMIN delete \
 -f https://raw.githubusercontent.com/verrazzano/verrazzano/v1.4.8/examples/multicluster/todo-list/verrazzano-project.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Delete the namespace &lt;code&gt;mc-todo-list&lt;/code&gt; after the application pods are terminated. The secrets created for the WebLogic domain also will be deleted.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ kubectl --kubeconfig $KUBECONFIG_ADMIN delete namespace mc-todo-list
$ kubectl --kubeconfig $KUBECONFIG_MANAGED1 delete namespace mc-todo-list
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

      </description>
    </item>
    
  </channel>
</rss>
